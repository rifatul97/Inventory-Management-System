package controller;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.input.KeyEvent;
import javafx.stage.Stage;
import main.Main;
import model.Inventory;
import model.Part;
import model.Product;

import java.io.IOException;
import java.net.URL;
import java.util.ResourceBundle;

/**
 * Controller class that controls the logic of the product screen of the application.
 *
 * @author Rifatul Karim
 * @version 1.0
 */
public class ProductScreenController implements Initializable {

    /**
     * Displays the id data of the product
     */
    @FXML private TextField productIDField;

    /**
     * Displays the Name of the product.
     */
    @FXML private TextField productNameField;

    /**
     * Displays the Inventory Level of the product.
     */
    @FXML private TextField productInvField;

    /**
     * Displays the name of the product.
     */
    @FXML private TextField productPriceField;

    /**
     * Displays the max data of the product.
     */
    @FXML private TextField productMaxField;

    /**
     * Displays the min data of the product.
     */
    @FXML private TextField productMinField;

    /**
     * Text field for the part search on the table.
     */
    @FXML private TextField searchPartTextField;

    /**
     * Text field for the product search on the table.
     */
    @FXML private TextField searchProductTextField;

    /**
     * Column that displays the Id of a part on the part table.
     */
    @FXML private TableColumn alltable_partID_col;

    /**
     * Column that displays the Id of a part on the part table.
     */
    @FXML private TableColumn alltable_partName_col;

    /**
     * Column that displays the Id of a part on the part table.
     */
    @FXML private TableColumn alltable_partInv_col;

    /**
     * Column that displays the Id of a part on the part table.
     */
    @FXML private TableColumn alltable_partPrice_col;

    /**
     * Column that displays the Id of a part on the product associate part table.
     */
    @FXML private TableColumn product_partID_col;

    /**
     * Column that displays the Name of a part on the product associate part table.
     */
    @FXML private TableColumn product_partName_col;

    /**
     * Column that displays the Inventory Level of a part on the product associate part table.
     */
    @FXML private TableColumn product_partInv_col;

    /**
     * Column that displays the Price of a part on the product associate part table.
     */
    @FXML private TableColumn product_partPrice_col;

    /**
     * Table view that displays all the available parts on the inventory.
     */
    @FXML private TableView partListTable;

    /**
     * Table view for the parts that is associated with the
     * current selected product on the screen.
     */
    @FXML private TableView productPartListTable;

    /**
     * Indicates the label of add/modify product on the screen.
     */
    @FXML private Label productScreenLabel;

    /**
     * Place to display the errors message.
     */
    @FXML private Label errorMessageLabel;

    /**
     * Place to display the name field error message.
     */
    @FXML private Label nameFieldErrorMsg;

    /**
     * Place to display the name field error message.
     */
    @FXML private Label maxFieldErrorMsg;

    /**
     * Place to display the name field error message.
     */
    @FXML private Label minFieldErrorMsg;

    /**
     * Place to display the price field error message.
     */
    @FXML private Label priceFieldErrorMsg;

    /**
     * Place to display the inventory field error message.
     */
    @FXML private Label invFieldErrorMsg;

    /**
     * Place to display the part search term field error message.
     */
    @FXML private Label partTextSearchErrorMsg;


    /**
     * Holds the data of the associate part of the product to show on the table view.
     * This data will be populate if the product data will be modify otherwise remains empty.
     */
    private final ObservableList<Part> productParts = FXCollections.observableArrayList();

    /**
     * Initiated upon calling this controller when selecting to modify/add product from the main screen.
     * This class requires to initializes the table column for the both tables and also will disable the
     * ability the edit data of the id field which will auto generated by the program. Afterwards, it
     * populates the table views with availiable parts from inventory and parts of the product.
     *
     * @param url The location used to resolve relative paths for the root object, or null if the location is not known.
     * @param resourceBundle The resources used to localize the root object, or null if the root object was not localized.
     */
    @Override
    public void initialize(URL url, ResourceBundle resourceBundle) {
        alltable_partID_col.setCellValueFactory(new PropertyValueFactory<>("id"));
        alltable_partName_col.setCellValueFactory(new PropertyValueFactory<>("name"));
        alltable_partInv_col.setCellValueFactory(new PropertyValueFactory<>("stock"));
        alltable_partPrice_col.setCellValueFactory(new PropertyValueFactory<>("price"));

        product_partID_col.setCellValueFactory(new PropertyValueFactory<>("id"));
        product_partName_col.setCellValueFactory(new PropertyValueFactory<>("name"));
        product_partPrice_col.setCellValueFactory(new PropertyValueFactory<>("price"));
        product_partInv_col.setCellValueFactory(new PropertyValueFactory<>("stock"));

        switch (MainScreenController.currentScreenState) {
            case ADD:
                productScreenLabel.setText("Add Part");
                break;
            case MODIFY:
                productScreenLabel.setText("Modify Part");
                break;
            default: break;
        }

        productIDField.setDisable(true);
        productPartListTable.setItems(productParts);
        partListTable.setItems(Inventory.getAllParts());
    }

    /**
     * Adds the selected part to the product.
     *
     * @param actionEvent add Part click handler
     */
    public void addPart_ButtonHandler(ActionEvent actionEvent) {
        Part selectedPart = (Part) partListTable.getSelectionModel().getSelectedItem();

        if (selectedPart == null) {return;}

        productParts.add(selectedPart);
        productPartListTable.refresh();
    }

    /**
     * Remove the selected part from the product.
     *
     * @param actionEvent remove Part click handler
     */
    public void removePart_ButtonHandler(ActionEvent actionEvent) {
        Part selectedPart = (Part) productPartListTable.getSelectionModel().getSelectedItem();

        if (selectedPart == null) {return; }

       if (AlertBoxHandler.displayConfirmationDialogue(1)) {
           for(Part part : productParts) {
               if(part.equals(selectedPart)) {
                   productParts.remove(part);
                   break;
               }
           }
           productPartListTable.refresh();
       }
    }

    /**
     * Functions to save the new or modified product data to the inventory. Check the data
     * validity and prints out error if present otherwise takes user to the main screen.
     *
     *
     * @param actionEvent save Data click handler
     */
    public void saveData_ButtonHandler(ActionEvent actionEvent) {
        removeErrorLabels();

        // calls the function that will check the input data.
        // If error presents then this function won't continue further.
        if(checkDataValidity() == true) { return; }

        // check if the state of the screen is add or modify. If Add, then it will need to
        // generate new Id by obtaining the current Inventory highest Id and add one.
        if(MainScreenController.currentScreenState == MainScreenController.ScreenState.MODIFY) {
            Product modifiedProduct = new Product(Integer.parseInt(productIDField.getText()),
                    productNameField.getText(),
                    Double.parseDouble(productPriceField.getText()),
                    Integer.parseInt(productInvField.getText()),
                    Integer.parseInt(productMinField.getText()),
                    Integer.parseInt(productMaxField.getText()));
            modifiedProduct.setAssociatedParts(productParts);
            Inventory.updateProduct(modifiedProduct.getId()-1, modifiedProduct);
        }
        else if(MainScreenController.currentScreenState == MainScreenController.ScreenState.ADD) {
            int max = 0;
            for(Product product : Inventory.getProducts()) {
                if (product.getId() > max) {
                    max = product.getId();
                }
            }
            Product newProduct = new Product(max+1,
                    productNameField.getText(),
                    Double.parseDouble(productPriceField.getText()),
                    Integer.parseInt(productInvField.getText()),
                    Integer.parseInt(productMinField.getText()),
                    Integer.parseInt(productMaxField.getText()));
            newProduct.setAssociatedParts(productParts);
            Inventory.addProduct(newProduct);
        }

        try {
            Parent root = FXMLLoader.load(getClass().getResource("/view/MainScreen.fxml"));
            MainScreenController.currentScreenState = MainScreenController.ScreenState.MAIN;

            Main.mainStage.setScene(new Scene(root));
            Main.mainStage.show();
        } catch (IOException e) {
            AlertBoxHandler.displayWarningDialogue("MainScreen.fxml");
        }
    }

    /**
     * Checks all the data inputs in the textfield and see if they are in right format and follows the rule.
     * Afterwards it will print out for each errors into the same screen otherwise returns false.
     *
     * @return returns true if there are error found.
     */
    private boolean checkDataValidity() {
        boolean errorFound = false;

        String name;
        int stockVal = -1, minVal = -1, maxVal = -1, machineIdVal = -1;
        double priceVal = -1;

        // firstly checks the format of each data.

        try { minVal = Integer.parseInt(productMinField.getText()); }
        catch (NumberFormatException e) {
            ScreenExceptionHandler.showErrorMsg(2, minFieldErrorMsg);
            errorFound = true;
        }
        try { maxVal = Integer.parseInt(productMaxField.getText()); }
        catch (NumberFormatException e) {
            ScreenExceptionHandler.showErrorMsg(2, maxFieldErrorMsg);
            errorFound = true;
        }
        try { stockVal = Integer.parseInt(productInvField.getText()); }
        catch (NumberFormatException e) {
            ScreenExceptionHandler.showErrorMsg(2, invFieldErrorMsg);
            errorFound = true;
        }
        try { priceVal = Double.parseDouble(productPriceField.getText()); }
        catch (NumberFormatException e) {
            ScreenExceptionHandler.showErrorMsg(2, priceFieldErrorMsg);
            errorFound = true;
        }

        if (productNameField.getText().trim().length() == 0) {
            ScreenExceptionHandler.showErrorMsg(1, nameFieldErrorMsg);
            errorFound = true;
        }

        if(errorFound) { return true; }

        /* if no error found upto this point means that all of the data were in right format and
           now compare each data with other */

        if (minVal < 0) {
            ScreenExceptionHandler.showErrorMsg(3, minFieldErrorMsg);
            errorFound = true;
        }
        if (maxVal < 0) {
            ScreenExceptionHandler.showErrorMsg(3, maxFieldErrorMsg);
            errorFound = true;
        }
        if (priceVal < 0) {
            ScreenExceptionHandler.showErrorMsg(3, priceFieldErrorMsg);
            errorFound = true;
        }

        // finally check if min > max and inventory value is between min and max.

        if (minVal > maxVal) {
            ScreenExceptionHandler.showErrorMsg(4, maxFieldErrorMsg);
            errorFound = true;
        }
        if (!(stockVal >= minVal && stockVal <= maxVal) ) {
            ScreenExceptionHandler.showErrorMsg(9, invFieldErrorMsg);
            errorFound = true;
        }

        return errorFound;
    }

    /**
     * Takes the user to the main screen.
     * Throws IOException if it cannot locate MainScreen.fxml
     *
     * @param actionEvent cancel Action
     */
    public void cancelAction (ActionEvent actionEvent) {
        removeErrorLabels();

        try {
            Parent root = FXMLLoader.load(getClass().getResource("/view/MainScreen.fxml"));
            Main.mainStage.setScene(new Scene(root));
            Main.mainStage.show();
        } catch (IOException e) { AlertBoxHandler.displayWarningDialogue("MainScreen.fxml"); }
    }

    /**
    * loads the data to modify selected from the main screen to the product screen
     *
     * @param selectedProduct loads the selected data from the product table of the main screen
    */
    public void loadSelectedProductData(Product selectedProduct) {

        for (Part part : selectedProduct.getAssociatedParts()) {
            productParts.add(part);
        }

        productIDField.setText(selectedProduct.getId() + "");
        productIDField.setDisable(true);
        productNameField.setText(selectedProduct.getName() + "");
        productInvField.setText(selectedProduct.getStock() + "");
        productMinField.setText(selectedProduct.getMin() + "");
        productPriceField.setText(selectedProduct.getPrice() + "");
        productMaxField.setText(selectedProduct.getMax()+ "");

        //currentProduct = selectedProduct;
        productPartListTable.setItems(productParts);
    }

    /**
     * Checks if the textfield of the part search is empty
     * then it will refresh the table to the original state.
     *
     * @param keyEvent search part on key pressed handler
     */
    public void partSearch_keyPressedHandler(KeyEvent keyEvent) {

        if(searchPartTextField == null) { return; }

        if(searchPartTextField.getText().trim().length() == 0) {
            partListTable.setItems(Inventory.getAllParts());
            partListTable.refresh();
        }

    }

    /**
     * The program looks up for the parts by id or name that partially matches
     * and load them into the table.
     *
     * The table will be refreshed to the original state if the textfield is empty.
     *
     * @param actionEvent Part search button action.
     */
    public void searchPart_ClickHandler(ActionEvent actionEvent) {

        int index = -1;
        String searchText = searchPartTextField.getText().trim();
        ObservableList<Part> partList = FXCollections.observableArrayList();

        try { index = Integer.parseInt(searchText); }
        catch (NumberFormatException e) { index = -1; }

        if(index != -1) {
            Part part = Inventory.lookupByPartID(index);
            if (part != null) { partList.add(part); }
        }

        ObservableList<Part> partList2 = Inventory.lookupByPartName(searchText);

        for(int i = 0; i < partList2.size(); i++) {
            partList.add(partList2.get(i));
        }

        partListTable.setItems(partList);
        partListTable.refresh();

        if (partList.size() == 0) {
            AlertBoxHandler.displayNotFoundDialogue(1);
        }
    }

    /**
    * Removes all the error messages on the screen.
    *
     */
    private void removeErrorLabels() {
        errorMessageLabel.setText("");
        nameFieldErrorMsg.setText("");
        invFieldErrorMsg.setText("");
        priceFieldErrorMsg.setText("");
        minFieldErrorMsg.setText("");
        maxFieldErrorMsg.setText("");
    }
}
